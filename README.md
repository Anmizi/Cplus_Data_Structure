# C/Cplus数据结构实现
   * [C/Cplus数据结构实现]()
      * [线性表](#线性表)
         * [定义](#定义)
         * [顺序存储结构](#顺序存储结构)
            * [顺序存储结构的基本操作](#顺序存储结构的基本操作)
         * [链式存储结构](#链式存储结构)
            * [链式存储结构的基本操作](#链式存储结构的基本操作)
         * [总结](#总结)
      * [栈和队列](#栈和队列)
      * [串](#串)
      * [树](#树)

## 线性表

### 定义

**线性表(List)**:零个或多个具有相同数据类型的数据元素的有序序列

通常记为 L = (a<sub>1 </sub> ,a<sub>2</sub>,a<sub>3</sub>,....a<sub>n</sub>)

- a<sub>1</sub>称为表头元素，a<sub>n</sub>称为表尾元素

- a<sub>i-1</sub>称为a<sub>i</sub>的直接前驱，a<sub>i+1</sub>称为a<sub>i</sub>的直接后继

- 线性表中所含数据元素的个数称为线性表的长度，n=0时该线性表长度为0

### 顺序存储结构

**顺序存储结构**:线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

**数据长度和线性表长度的区别**:

- 数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的
- 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。
- 在任意时刻，线性表的长度应该小于等于数组的长度。

#### 顺序存储结构的基本操作

**获得元素操作**

对于线性表的顺序存储结构来说，如果我们要实现获取元素操作，即将线性表L中的第i个位置元素值返回，就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。

**插入操作**

插入算法的思路：

1. 如果插入位置不合理，抛出异常；
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
3. 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
4. 将要插入元素填入位置i处；
5. 表长加1。

**删除操作**

删除算法的思路：

1. 如果删除位置不合理，抛出异常
2. 取出删除元素；
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
4. 表长减1。

**线性表顺序存储结构的优缺点**

- *优点:* 无须为表示表中元素之间的逻辑关系而增加额外的存空间，可以快速地存取表中任一位置的元素
- *缺点:* 插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，造成存储空间的“碎片”

### 链式存储结构

**线性表的链式存储结构:** 是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

**数据域**: 我们把存储数据元素信息的域称为数据域

**指针域**: 把存储直接后继位置的域称为指针域。

**结点**: 由数据域和指针域组成的数据元素的存储映像,称为结点(Node)

**头指针和头结点的区别**:

- 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针
- 头指针具有标识作用，所以常用头指针冠以链表的名字
- 无论链表是否为空，头指针均不为空。头指针是链表的必要元素
- 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）
- 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了
- 头结点不一定是链表必须要素

#### 链式存储结构的基本操作

**获取元素操作**

获得链表第i个数据的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，返回结点p的数据。

**插入操作**

单链表第i个数据插入结点的算法思路：

1. 声明一结点p指向链表第一个结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，在系统中生成一个空结点s
5. 将数据元素e赋值给s->data
6. 单链表的插入标准语句s->next=p->nextp->next=s
7. 返回成功

**删除操作**

单链表第i个数据删除结点的算法思路：

1. 声明一结点p指向链表第一个结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，将欲删除的结点p->next赋值给q
5. 单链表的删除标准语句p->next=q->next
6. 将q结点中的数据赋值给e，作为返回
7. 释放q结点
8. 返回成功。

**整表创建算法**

单链表整表创建的算法思路：

1. 声明一结点p和计数器变量i

2. 初始化一空链表L

3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表

4. 循环：

   - 生成一新结点赋值给p
   - 随机生成一数字赋值给p的数据域p->data
   - 将p插入到头结点与前一新结点之间

      

**整表删除算法**

单链表整表删除的算法思路如下：

1. 声明一结点p和q
2. 将第一个结点赋值给p
3. 循环：
   - 将下一结点赋值给q
   - 释放p
   - 将q赋值给p

### 总结

![](https://gitee.com/Stubborner/images/raw/master/images/image-20201218202052400.png)

*若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。*

*当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。*

## 栈和队列

## 串

## 树



